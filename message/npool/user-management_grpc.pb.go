// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package npool

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// UserClient is the client API for User service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UserClient interface {
	// Method Version
	Version(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*VersionResponse, error)
	//
	//User can choose signup with username, email, phone or only emial or only phone.
	SignUp(ctx context.Context, in *SignupRequest, opts ...grpc.CallOption) (*SignupResponse, error)
	//
	//Set user password.
	SetPassword(ctx context.Context, in *SetPasswordRequest, opts ...grpc.CallOption) (*SetPasswordResponse, error)
	//
	//Get a user's info by his(her) id, this api can be request by user self of admin.
	GetUser(ctx context.Context, in *GetUserRequest, opts ...grpc.CallOption) (*GetUserResponse, error)
	//
	//Update user's basic info.
	UpdateUserInfo(ctx context.Context, in *UpdateUserInfoRequest, opts ...grpc.CallOption) (*UpdateUserInfoResponse, error)
	//
	//Bind user's phone number.
	//Before bind a phone number to user, it needs to send phone verify code and confirm the verify code user input.
	//Need apis: https://user.npool.top/v1/send/sms, https://user.npool.top/v1/confirm-sms-verify-code
	BindUserPhone(ctx context.Context, in *BindUserPhoneRequest, opts ...grpc.CallOption) (*BindUserPhoneResponse, error)
	//
	//Bind user's email address.
	//Before bind a email address to user, it needs to send email verify code and confirm the verify code user input.
	//Need apis: https://user.npool.top/v1/send/email, https://user.npool.top/v1/confirm-email-verify-code
	BindUserEmail(ctx context.Context, in *BindUserEmailRequest, opts ...grpc.CallOption) (*BindUserEmailResponse, error)
	//
	//Unbind user's phone number.
	//Before unbind user's phone number, it needs to send phone verify code and confirm the verify code user input.
	//Need apis: https://user.npool.top/v1/send/sms, https://user.npool.top/v1/confirm-sms-verify-code
	UnbindUserPhone(ctx context.Context, in *UnbindUserPhoneRequest, opts ...grpc.CallOption) (*UnbindUserPhoneResponse, error)
	//
	//Unbind user's email address.
	//Before unbind user's email address, it needs to send email verify code and confirm the verify code user input.
	//Need apis: https://user.npool.top/v1/send/email, https://user.npool.top/v1/confirm-email-verify-code
	UnbindUserEmail(ctx context.Context, in *UnbindUserEmailRequest, opts ...grpc.CallOption) (*UnbindUserEmailResponse, error)
	//
	//Link to a third-party oauth. save the UserId from third-party into mysql.
	//During Linking, user need to authenticate in third-party and use login-oauth api to get access_token and then get user info from third-party(provider).
	//need api: https://login.npool.top/v1/login/oauth
	BindThirdParty(ctx context.Context, in *BindThirdPartyRequest, opts ...grpc.CallOption) (*BindThirdPartyResponse, error)
	//
	//Unlink a third-party oauth. Delete the UserId we saved from mysql.
	UnbindThirdParty(ctx context.Context, in *UnbindThirdPartyRequest, opts ...grpc.CallOption) (*UnbindThirdPartyResponse, error)
	//
	//Change user's password. Before change users password, system need the user to do an authentication.
	ChangeUserPassword(ctx context.Context, in *ChangeUserPasswordRequest, opts ...grpc.CallOption) (*ChangeUserPasswordResponse, error)
	//
	//Forget password.
	//If user forgets his(her) password, he(she) firstly need to authenticate identity and then reset his(her) password.
	ForgetPassword(ctx context.Context, in *ForgetPasswordRequest, opts ...grpc.CallOption) (*ForgetPasswordResponse, error)
	//
	//Add user.
	AddUser(ctx context.Context, in *AddUserRequest, opts ...grpc.CallOption) (*AddUserResponse, error)
	//
	//Delete users.
	//This api can only be used by admin. When deleting users, service will not only delete basic user info, but also use other apis to delete connections among other service.
	DeleteUser(ctx context.Context, in *DeleteUserRequest, opts ...grpc.CallOption) (*DeleteUserResponse, error)
	//
	//Logout user.
	//Permanently delete user personal account, user will not be able to log in after deletion. And service will not only delete basic user info, but also use other apis to delete connections among other service.
	LogoutUser(ctx context.Context, in *LogoutUserRequest, opts ...grpc.CallOption) (*LogoutUserResponse, error)
	//
	//Frozen user.
	FrozenUser(ctx context.Context, in *FrozenUserRequest, opts ...grpc.CallOption) (*FrozenUserResponse, error)
	//
	//Unfrozen user.
	UnfrozenUser(ctx context.Context, in *UnfrozenUserRequest, opts ...grpc.CallOption) (*UnfrozenUserResponse, error)
	//
	//Get frozen user list.
	GetFrozenUsers(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GetFrozenUsersResponse, error)
	//
	//Get user providers info.
	GetUserProviders(ctx context.Context, in *GetUserProvidersRequest, opts ...grpc.CallOption) (*GetUserProvidersResponse, error)
}

type userClient struct {
	cc grpc.ClientConnInterface
}

func NewUserClient(cc grpc.ClientConnInterface) UserClient {
	return &userClient{cc}
}

func (c *userClient) Version(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*VersionResponse, error) {
	out := new(VersionResponse)
	err := c.cc.Invoke(ctx, "/user.v1.User/Version", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) SignUp(ctx context.Context, in *SignupRequest, opts ...grpc.CallOption) (*SignupResponse, error) {
	out := new(SignupResponse)
	err := c.cc.Invoke(ctx, "/user.v1.User/SignUp", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) SetPassword(ctx context.Context, in *SetPasswordRequest, opts ...grpc.CallOption) (*SetPasswordResponse, error) {
	out := new(SetPasswordResponse)
	err := c.cc.Invoke(ctx, "/user.v1.User/SetPassword", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) GetUser(ctx context.Context, in *GetUserRequest, opts ...grpc.CallOption) (*GetUserResponse, error) {
	out := new(GetUserResponse)
	err := c.cc.Invoke(ctx, "/user.v1.User/GetUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) UpdateUserInfo(ctx context.Context, in *UpdateUserInfoRequest, opts ...grpc.CallOption) (*UpdateUserInfoResponse, error) {
	out := new(UpdateUserInfoResponse)
	err := c.cc.Invoke(ctx, "/user.v1.User/UpdateUserInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) BindUserPhone(ctx context.Context, in *BindUserPhoneRequest, opts ...grpc.CallOption) (*BindUserPhoneResponse, error) {
	out := new(BindUserPhoneResponse)
	err := c.cc.Invoke(ctx, "/user.v1.User/BindUserPhone", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) BindUserEmail(ctx context.Context, in *BindUserEmailRequest, opts ...grpc.CallOption) (*BindUserEmailResponse, error) {
	out := new(BindUserEmailResponse)
	err := c.cc.Invoke(ctx, "/user.v1.User/BindUserEmail", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) UnbindUserPhone(ctx context.Context, in *UnbindUserPhoneRequest, opts ...grpc.CallOption) (*UnbindUserPhoneResponse, error) {
	out := new(UnbindUserPhoneResponse)
	err := c.cc.Invoke(ctx, "/user.v1.User/UnbindUserPhone", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) UnbindUserEmail(ctx context.Context, in *UnbindUserEmailRequest, opts ...grpc.CallOption) (*UnbindUserEmailResponse, error) {
	out := new(UnbindUserEmailResponse)
	err := c.cc.Invoke(ctx, "/user.v1.User/UnbindUserEmail", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) BindThirdParty(ctx context.Context, in *BindThirdPartyRequest, opts ...grpc.CallOption) (*BindThirdPartyResponse, error) {
	out := new(BindThirdPartyResponse)
	err := c.cc.Invoke(ctx, "/user.v1.User/BindThirdParty", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) UnbindThirdParty(ctx context.Context, in *UnbindThirdPartyRequest, opts ...grpc.CallOption) (*UnbindThirdPartyResponse, error) {
	out := new(UnbindThirdPartyResponse)
	err := c.cc.Invoke(ctx, "/user.v1.User/UnbindThirdParty", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) ChangeUserPassword(ctx context.Context, in *ChangeUserPasswordRequest, opts ...grpc.CallOption) (*ChangeUserPasswordResponse, error) {
	out := new(ChangeUserPasswordResponse)
	err := c.cc.Invoke(ctx, "/user.v1.User/ChangeUserPassword", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) ForgetPassword(ctx context.Context, in *ForgetPasswordRequest, opts ...grpc.CallOption) (*ForgetPasswordResponse, error) {
	out := new(ForgetPasswordResponse)
	err := c.cc.Invoke(ctx, "/user.v1.User/ForgetPassword", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) AddUser(ctx context.Context, in *AddUserRequest, opts ...grpc.CallOption) (*AddUserResponse, error) {
	out := new(AddUserResponse)
	err := c.cc.Invoke(ctx, "/user.v1.User/AddUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) DeleteUser(ctx context.Context, in *DeleteUserRequest, opts ...grpc.CallOption) (*DeleteUserResponse, error) {
	out := new(DeleteUserResponse)
	err := c.cc.Invoke(ctx, "/user.v1.User/DeleteUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) LogoutUser(ctx context.Context, in *LogoutUserRequest, opts ...grpc.CallOption) (*LogoutUserResponse, error) {
	out := new(LogoutUserResponse)
	err := c.cc.Invoke(ctx, "/user.v1.User/LogoutUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) FrozenUser(ctx context.Context, in *FrozenUserRequest, opts ...grpc.CallOption) (*FrozenUserResponse, error) {
	out := new(FrozenUserResponse)
	err := c.cc.Invoke(ctx, "/user.v1.User/FrozenUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) UnfrozenUser(ctx context.Context, in *UnfrozenUserRequest, opts ...grpc.CallOption) (*UnfrozenUserResponse, error) {
	out := new(UnfrozenUserResponse)
	err := c.cc.Invoke(ctx, "/user.v1.User/UnfrozenUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) GetFrozenUsers(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GetFrozenUsersResponse, error) {
	out := new(GetFrozenUsersResponse)
	err := c.cc.Invoke(ctx, "/user.v1.User/GetFrozenUsers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) GetUserProviders(ctx context.Context, in *GetUserProvidersRequest, opts ...grpc.CallOption) (*GetUserProvidersResponse, error) {
	out := new(GetUserProvidersResponse)
	err := c.cc.Invoke(ctx, "/user.v1.User/GetUserProviders", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserServer is the server API for User service.
// All implementations must embed UnimplementedUserServer
// for forward compatibility
type UserServer interface {
	// Method Version
	Version(context.Context, *emptypb.Empty) (*VersionResponse, error)
	//
	//User can choose signup with username, email, phone or only emial or only phone.
	SignUp(context.Context, *SignupRequest) (*SignupResponse, error)
	//
	//Set user password.
	SetPassword(context.Context, *SetPasswordRequest) (*SetPasswordResponse, error)
	//
	//Get a user's info by his(her) id, this api can be request by user self of admin.
	GetUser(context.Context, *GetUserRequest) (*GetUserResponse, error)
	//
	//Update user's basic info.
	UpdateUserInfo(context.Context, *UpdateUserInfoRequest) (*UpdateUserInfoResponse, error)
	//
	//Bind user's phone number.
	//Before bind a phone number to user, it needs to send phone verify code and confirm the verify code user input.
	//Need apis: https://user.npool.top/v1/send/sms, https://user.npool.top/v1/confirm-sms-verify-code
	BindUserPhone(context.Context, *BindUserPhoneRequest) (*BindUserPhoneResponse, error)
	//
	//Bind user's email address.
	//Before bind a email address to user, it needs to send email verify code and confirm the verify code user input.
	//Need apis: https://user.npool.top/v1/send/email, https://user.npool.top/v1/confirm-email-verify-code
	BindUserEmail(context.Context, *BindUserEmailRequest) (*BindUserEmailResponse, error)
	//
	//Unbind user's phone number.
	//Before unbind user's phone number, it needs to send phone verify code and confirm the verify code user input.
	//Need apis: https://user.npool.top/v1/send/sms, https://user.npool.top/v1/confirm-sms-verify-code
	UnbindUserPhone(context.Context, *UnbindUserPhoneRequest) (*UnbindUserPhoneResponse, error)
	//
	//Unbind user's email address.
	//Before unbind user's email address, it needs to send email verify code and confirm the verify code user input.
	//Need apis: https://user.npool.top/v1/send/email, https://user.npool.top/v1/confirm-email-verify-code
	UnbindUserEmail(context.Context, *UnbindUserEmailRequest) (*UnbindUserEmailResponse, error)
	//
	//Link to a third-party oauth. save the UserId from third-party into mysql.
	//During Linking, user need to authenticate in third-party and use login-oauth api to get access_token and then get user info from third-party(provider).
	//need api: https://login.npool.top/v1/login/oauth
	BindThirdParty(context.Context, *BindThirdPartyRequest) (*BindThirdPartyResponse, error)
	//
	//Unlink a third-party oauth. Delete the UserId we saved from mysql.
	UnbindThirdParty(context.Context, *UnbindThirdPartyRequest) (*UnbindThirdPartyResponse, error)
	//
	//Change user's password. Before change users password, system need the user to do an authentication.
	ChangeUserPassword(context.Context, *ChangeUserPasswordRequest) (*ChangeUserPasswordResponse, error)
	//
	//Forget password.
	//If user forgets his(her) password, he(she) firstly need to authenticate identity and then reset his(her) password.
	ForgetPassword(context.Context, *ForgetPasswordRequest) (*ForgetPasswordResponse, error)
	//
	//Add user.
	AddUser(context.Context, *AddUserRequest) (*AddUserResponse, error)
	//
	//Delete users.
	//This api can only be used by admin. When deleting users, service will not only delete basic user info, but also use other apis to delete connections among other service.
	DeleteUser(context.Context, *DeleteUserRequest) (*DeleteUserResponse, error)
	//
	//Logout user.
	//Permanently delete user personal account, user will not be able to log in after deletion. And service will not only delete basic user info, but also use other apis to delete connections among other service.
	LogoutUser(context.Context, *LogoutUserRequest) (*LogoutUserResponse, error)
	//
	//Frozen user.
	FrozenUser(context.Context, *FrozenUserRequest) (*FrozenUserResponse, error)
	//
	//Unfrozen user.
	UnfrozenUser(context.Context, *UnfrozenUserRequest) (*UnfrozenUserResponse, error)
	//
	//Get frozen user list.
	GetFrozenUsers(context.Context, *emptypb.Empty) (*GetFrozenUsersResponse, error)
	//
	//Get user providers info.
	GetUserProviders(context.Context, *GetUserProvidersRequest) (*GetUserProvidersResponse, error)
	mustEmbedUnimplementedUserServer()
}

// UnimplementedUserServer must be embedded to have forward compatible implementations.
type UnimplementedUserServer struct {
}

func (UnimplementedUserServer) Version(context.Context, *emptypb.Empty) (*VersionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Version not implemented")
}
func (UnimplementedUserServer) SignUp(context.Context, *SignupRequest) (*SignupResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SignUp not implemented")
}
func (UnimplementedUserServer) SetPassword(context.Context, *SetPasswordRequest) (*SetPasswordResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetPassword not implemented")
}
func (UnimplementedUserServer) GetUser(context.Context, *GetUserRequest) (*GetUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUser not implemented")
}
func (UnimplementedUserServer) UpdateUserInfo(context.Context, *UpdateUserInfoRequest) (*UpdateUserInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateUserInfo not implemented")
}
func (UnimplementedUserServer) BindUserPhone(context.Context, *BindUserPhoneRequest) (*BindUserPhoneResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BindUserPhone not implemented")
}
func (UnimplementedUserServer) BindUserEmail(context.Context, *BindUserEmailRequest) (*BindUserEmailResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BindUserEmail not implemented")
}
func (UnimplementedUserServer) UnbindUserPhone(context.Context, *UnbindUserPhoneRequest) (*UnbindUserPhoneResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnbindUserPhone not implemented")
}
func (UnimplementedUserServer) UnbindUserEmail(context.Context, *UnbindUserEmailRequest) (*UnbindUserEmailResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnbindUserEmail not implemented")
}
func (UnimplementedUserServer) BindThirdParty(context.Context, *BindThirdPartyRequest) (*BindThirdPartyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BindThirdParty not implemented")
}
func (UnimplementedUserServer) UnbindThirdParty(context.Context, *UnbindThirdPartyRequest) (*UnbindThirdPartyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnbindThirdParty not implemented")
}
func (UnimplementedUserServer) ChangeUserPassword(context.Context, *ChangeUserPasswordRequest) (*ChangeUserPasswordResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChangeUserPassword not implemented")
}
func (UnimplementedUserServer) ForgetPassword(context.Context, *ForgetPasswordRequest) (*ForgetPasswordResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ForgetPassword not implemented")
}
func (UnimplementedUserServer) AddUser(context.Context, *AddUserRequest) (*AddUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddUser not implemented")
}
func (UnimplementedUserServer) DeleteUser(context.Context, *DeleteUserRequest) (*DeleteUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteUser not implemented")
}
func (UnimplementedUserServer) LogoutUser(context.Context, *LogoutUserRequest) (*LogoutUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LogoutUser not implemented")
}
func (UnimplementedUserServer) FrozenUser(context.Context, *FrozenUserRequest) (*FrozenUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FrozenUser not implemented")
}
func (UnimplementedUserServer) UnfrozenUser(context.Context, *UnfrozenUserRequest) (*UnfrozenUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnfrozenUser not implemented")
}
func (UnimplementedUserServer) GetFrozenUsers(context.Context, *emptypb.Empty) (*GetFrozenUsersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFrozenUsers not implemented")
}
func (UnimplementedUserServer) GetUserProviders(context.Context, *GetUserProvidersRequest) (*GetUserProvidersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserProviders not implemented")
}
func (UnimplementedUserServer) mustEmbedUnimplementedUserServer() {}

// UnsafeUserServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserServer will
// result in compilation errors.
type UnsafeUserServer interface {
	mustEmbedUnimplementedUserServer()
}

func RegisterUserServer(s grpc.ServiceRegistrar, srv UserServer) {
	s.RegisterService(&User_ServiceDesc, srv)
}

func _User_Version_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).Version(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/user.v1.User/Version",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).Version(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_SignUp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SignupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).SignUp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/user.v1.User/SignUp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).SignUp(ctx, req.(*SignupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_SetPassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetPasswordRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).SetPassword(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/user.v1.User/SetPassword",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).SetPassword(ctx, req.(*SetPasswordRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_GetUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).GetUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/user.v1.User/GetUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).GetUser(ctx, req.(*GetUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_UpdateUserInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateUserInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).UpdateUserInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/user.v1.User/UpdateUserInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).UpdateUserInfo(ctx, req.(*UpdateUserInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_BindUserPhone_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BindUserPhoneRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).BindUserPhone(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/user.v1.User/BindUserPhone",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).BindUserPhone(ctx, req.(*BindUserPhoneRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_BindUserEmail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BindUserEmailRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).BindUserEmail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/user.v1.User/BindUserEmail",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).BindUserEmail(ctx, req.(*BindUserEmailRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_UnbindUserPhone_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnbindUserPhoneRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).UnbindUserPhone(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/user.v1.User/UnbindUserPhone",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).UnbindUserPhone(ctx, req.(*UnbindUserPhoneRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_UnbindUserEmail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnbindUserEmailRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).UnbindUserEmail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/user.v1.User/UnbindUserEmail",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).UnbindUserEmail(ctx, req.(*UnbindUserEmailRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_BindThirdParty_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BindThirdPartyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).BindThirdParty(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/user.v1.User/BindThirdParty",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).BindThirdParty(ctx, req.(*BindThirdPartyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_UnbindThirdParty_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnbindThirdPartyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).UnbindThirdParty(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/user.v1.User/UnbindThirdParty",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).UnbindThirdParty(ctx, req.(*UnbindThirdPartyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_ChangeUserPassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChangeUserPasswordRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).ChangeUserPassword(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/user.v1.User/ChangeUserPassword",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).ChangeUserPassword(ctx, req.(*ChangeUserPasswordRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_ForgetPassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ForgetPasswordRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).ForgetPassword(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/user.v1.User/ForgetPassword",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).ForgetPassword(ctx, req.(*ForgetPasswordRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_AddUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).AddUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/user.v1.User/AddUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).AddUser(ctx, req.(*AddUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_DeleteUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).DeleteUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/user.v1.User/DeleteUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).DeleteUser(ctx, req.(*DeleteUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_LogoutUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogoutUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).LogoutUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/user.v1.User/LogoutUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).LogoutUser(ctx, req.(*LogoutUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_FrozenUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FrozenUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).FrozenUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/user.v1.User/FrozenUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).FrozenUser(ctx, req.(*FrozenUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_UnfrozenUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnfrozenUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).UnfrozenUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/user.v1.User/UnfrozenUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).UnfrozenUser(ctx, req.(*UnfrozenUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_GetFrozenUsers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).GetFrozenUsers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/user.v1.User/GetFrozenUsers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).GetFrozenUsers(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_GetUserProviders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserProvidersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).GetUserProviders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/user.v1.User/GetUserProviders",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).GetUserProviders(ctx, req.(*GetUserProvidersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// User_ServiceDesc is the grpc.ServiceDesc for User service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var User_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "user.v1.User",
	HandlerType: (*UserServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Version",
			Handler:    _User_Version_Handler,
		},
		{
			MethodName: "SignUp",
			Handler:    _User_SignUp_Handler,
		},
		{
			MethodName: "SetPassword",
			Handler:    _User_SetPassword_Handler,
		},
		{
			MethodName: "GetUser",
			Handler:    _User_GetUser_Handler,
		},
		{
			MethodName: "UpdateUserInfo",
			Handler:    _User_UpdateUserInfo_Handler,
		},
		{
			MethodName: "BindUserPhone",
			Handler:    _User_BindUserPhone_Handler,
		},
		{
			MethodName: "BindUserEmail",
			Handler:    _User_BindUserEmail_Handler,
		},
		{
			MethodName: "UnbindUserPhone",
			Handler:    _User_UnbindUserPhone_Handler,
		},
		{
			MethodName: "UnbindUserEmail",
			Handler:    _User_UnbindUserEmail_Handler,
		},
		{
			MethodName: "BindThirdParty",
			Handler:    _User_BindThirdParty_Handler,
		},
		{
			MethodName: "UnbindThirdParty",
			Handler:    _User_UnbindThirdParty_Handler,
		},
		{
			MethodName: "ChangeUserPassword",
			Handler:    _User_ChangeUserPassword_Handler,
		},
		{
			MethodName: "ForgetPassword",
			Handler:    _User_ForgetPassword_Handler,
		},
		{
			MethodName: "AddUser",
			Handler:    _User_AddUser_Handler,
		},
		{
			MethodName: "DeleteUser",
			Handler:    _User_DeleteUser_Handler,
		},
		{
			MethodName: "LogoutUser",
			Handler:    _User_LogoutUser_Handler,
		},
		{
			MethodName: "FrozenUser",
			Handler:    _User_FrozenUser_Handler,
		},
		{
			MethodName: "UnfrozenUser",
			Handler:    _User_UnfrozenUser_Handler,
		},
		{
			MethodName: "GetFrozenUsers",
			Handler:    _User_GetFrozenUsers_Handler,
		},
		{
			MethodName: "GetUserProviders",
			Handler:    _User_GetUserProviders_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "npool/user-management.proto",
}
